/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package advent_of_code

import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.io.BufferedReader
import java.io.FileReader
import kotlin.math.max

class AdventOfCode2021Test {
    private val adventOfCode2021 = AdventOfCode2021()

    @Nested
    inner class Day1 {
        @Test
        fun `Should count the number of times a depth measurement increases`() {
            val report = listOf(199, 200, 208, 210, 200, 207, 240, 269, 260, 263)

            val increaseCounter = adventOfCode2021.countingDepthMeasurementIncreases(report)

            assertThat(increaseCounter).isEqualTo(7)
        }

        @Test
        fun `Should count the number of times a depth measurement increases given a bigger puzzle`() {
            val filePath = "src/test/resources/day1"
            val depthMeasurements =
                BufferedReader(FileReader("$filePath/puzzleInput.txt")).lines().map { it.toInt() }.toList()

            val increaseCounter = adventOfCode2021.countingDepthMeasurementIncreases(depthMeasurements)

            assertThat(increaseCounter).isEqualTo(1713)
        }

        @Test
        fun `_Prod_ should count the number of times the sum of measurements in a sliding window increases`() {
            val filePath = "src/test/resources/day1"
            val report =
                BufferedReader(FileReader("$filePath/puzzleInput.txt")).lines().map { it.toInt() }.toList()

            val slidingWindowData = adventOfCode2021.makeListOfThreeSlidingWindowData(report, 3)
            val totalMeasuresIncrease = adventOfCode2021.countingDepthMeasurementIncreases(slidingWindowData)

            assertThat(totalMeasuresIncrease).isEqualTo(1734)

        }

        @Test
        fun `_example_ Should count the number of times the sum of measurements in a sliding window increases`() {
            val report = listOf(199, 200, 208, 210, 200, 207, 240, 269, 260, 263)

            val slidingWindowData = adventOfCode2021.makeListOfThreeSlidingWindowData(report, 3)
            val totalMeasuresIncrease = adventOfCode2021.countingDepthMeasurementIncreases(slidingWindowData)

            assertThat(totalMeasuresIncrease).isEqualTo(5)

        }

        @Test
        fun `_example_ count the number of times the sum of measurements in this sliding window increases`() {
            val measurements: Map<Char, List<Int>> = mapOf(
                'A' to listOf(199, 200, 208),
                'B' to listOf(200, 208, 210),
                'C' to listOf(208, 210, 200),
                'D' to listOf(210, 200, 207),
                'E' to listOf(200, 207, 240),
                'F' to listOf(207, 240, 269),
                'G' to listOf(240, 269, 260),
                'H' to listOf(269, 260, 263),
            )


            val numberOfIncrease = adventOfCode2021.countingIncresalOfMeasurements(measurements)
            assertThat(numberOfIncrease).isEqualTo(5)
        }

        @Test
        fun `_example_ Should build a list of sums based on a three-measurement sliding window technique`() {
            val report = listOf(199, 200, 208, 210, 200, 207, 240, 269, 260, 263)
            val k = 3

            val slidingWindowData = adventOfCode2021.makeListOfThreeSlidingWindowData(report, k)

            assertThat(slidingWindowData).isEqualTo(listOf(607, 618, 618, 617, 647, 716, 769, 792))
        }

        @Nested
        inner class SlidingWindowTechnique {

            @Test
            fun `Should find the maximum of tha subarray of size K with brute force mechanism`() {
                val myArray = listOf(1, 4, 2, 10, 2, 3, 1, 0, 20)
                val k = 4
                val maxSum = findMaxSumOfArrayWithBruteForce(myArray, k)

                assertThat(maxSum).isEqualTo(24)

            }

            private fun findMaxSumOfArrayWithBruteForce(myArray: List<Int>, k: Int): Int {
                var maxSum = Integer.MIN_VALUE
                val sizeOfArray = myArray.size
                for (i in 0..sizeOfArray - k + 1) {
                    var currentSum = 0
                    var j = 0
                    while (j < k && i + j < sizeOfArray) {
                        currentSum += myArray[i + j]
                        maxSum = max(currentSum, maxSum)
                        j++
                    }
                }
                return maxSum
            }
        }
    }

    @Nested
    inner class Day2 {
        @Test
        fun `Example_ move under water increases only the horizontal position and the depth`() {
            val instructions = listOf(
                "forward 5",
                "down 5",
                "forward 8",
                "up 3",
                "down 8",
                "forward 2"
            )

            val pair = adventOfCode2021.getSubmarinPosition(instructions)

            assertThat(pair.second).isEqualTo(15)
            assertThat(pair.first).isEqualTo(10)
            assertThat(pair.second.times(pair.first)).isEqualTo(150)
        }

        @Test
        fun `Example2_ move under water increase the horizontal position, the depth and the aim `(){
            var horizontal = 0
            var depth = 0
            var aim = 0

            val instructions = listOf(
                "forward 5",
                "down 5",
                "forward 8",
                "up 3",
                "down 8",
                "forward 2"
            )

            instructions.forEach {
                val instruction = it.split(" ")
                val command = instruction[0]
                val distance = instruction[1].toInt()
                when(command){
                    "forward" -> {
                        horizontal += distance
                        depth += aim.times(distance)
                    }
                    "down" -> {
                        aim += distance
                    }
                    "up" -> {
                        aim -= distance
                    }
                }
            }

            assertThat(horizontal).isEqualTo(15).`as`("resulted horizontal position is null")
            assertThat(depth).isEqualTo(60)
            assertThat(horizontal.times(depth)).isEqualTo(900)
        }

        @Test
        fun `Production__ do move under water and return the horizontal position and the depth`(){
            val filePath = "src/test/resources/day2"
            val instructions = BufferedReader(FileReader("$filePath/puzzleInput.txt")).lines().map { it }.toList()
            val pair = adventOfCode2021.getSubmarinPosition(instructions)

            assertThat(pair.second).isEqualTo(1817)
            assertThat(pair.first).isEqualTo(1072)
            assertThat(pair.second.times(pair.first)).isEqualTo(1947824)
        }

        @Test
        fun `Production_ do move under water but change the depth based on the aim`(){
            val filePath = "src/test/resources/day2"
            val instructions = BufferedReader(FileReader("$filePath/puzzleInput.txt")).lines().map { it }.toList()
            val (horizontal, depth) = adjustMovesBasedOnTheAim(instructions)

            assertThat(horizontal).isEqualTo(1817).`as`("resulted horizontal position is null")
            assertThat(depth).isEqualTo(997833).`as`("The expected depth is wrong")
            assertThat(horizontal.times(depth)).isEqualTo(1813062561)
        }

        private fun adjustMovesBasedOnTheAim(instructions: MutableList<String>): Pair<Int, Int> {
            var horizontal = 0
            var depth = 0
            var aim = 0
            instructions.forEach {
                val instruction = it.split(" ")
                val command = instruction[0]
                val distance = instruction[1].toInt()
                when (command) {
                    "forward" -> {
                        horizontal += distance
                        depth += aim.times(distance)
                    }
                    "down" -> {
                        aim += distance
                    }
                    "up" -> {
                        aim -= distance
                    }
                }
            }
            return Pair(horizontal, depth)
        }


    }


}
